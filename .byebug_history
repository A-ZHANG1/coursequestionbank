c
original_problem[:rendered_text]
original_problem
original_problem[:json]
original_problem
n
new_problem[:json]
new_problem
new_problem[:rendered_text]
original_problem[:rendered_text]
original_problem
c
new_problem[:uid]
new_problem
c
new_problem[:json]
original_problem[:json]
original_problem = Problem.find_by_uid(params[:parent_uid])
Problem.find_by_uid(id)
id = params[:parent_uid]
params[:parent_uid]
find_by_uid(params[:parents_uid])
find_by_uid(params[:parent_uid])
original_problem = find_by_uid(params[:parent_uid])
new_problem = RuqlReader.read_problem(@current_user, params[:ruql_source])
c
n
c
database_question[:json]
params[:ruql_source].to_json
params[:ruql_source]
database_question[:json]
database_question = Problem.find_by_uid(params[:parent_uid])
params[:ruql_source]
params[:ruql_source].to_s
params[:ruql_source].to_s.to_json
params[:ruql_source].to_s
problem[:json].to_s
problem[:json]
params[:ruql_source].to_s
params[:ruql_source]
problem[:json]
problem
params[:parent_uid]
problem
problem = RuqlReader.read_problem(@current_user, params[:ruql_source])
@current_user
@@current_user
continue
"\"choice_answer :raw => true do\\r\\n  uid \\\"8cc5233b-617b-4b35-85ba-43197d7dea26\\\"\\r\\n  # uid \\\"2c16b9ea-accf-4fa8-abbc-b52712b87b6c\\\"\\r\\n  text \\\"Based123 on what you\\u2019ve seen of Rails, what kind of object is likely being yielded in the migration code:\\\\n<pre>\\\\ndef up\\\\n  create_table 'movies' do |t|\\\\n    t.datetime 'release_date'\\\\n    ...\\\\n  end\\\\nend\\\\n</pre>\\\"\\r\\n  answer \\\"An object representing a table\\\", :explanation => \\\"\\\\nThis is a good example of trying to infer intent from good variable names and good code structure.  Since we are calling a method <tt>release_date</tt> on <tt>t</tt>, we might ask: on what types of objects might such a method be meaningfully defined?  Certainly not a database, since a database can have many tables, anby one of which might have one or more Datetime columns; nor an instance of a model, for the same reason.  It does, however, make sense if <tt>t</tt> is a table to specify a Datetime column for that particular table.\\\\n\\\"\\r\\n  distractor \\\"An object representing the database\\\", :explanation => \\\"\\\\nThis is a good example of trying to infer intent from good variable names and good code structure.  Since we are calling a method <tt>release_date</tt> on <tt>t</tt>, we might ask: on what types of objects might such a method be meaningfully defined?  Certainly not a database, since a database can have many tables, anby one of which might have one or more Datetime columns; nor an instance of a model, for the same reason.  It does, however, make sense if <tt>t</tt> is a table to specify a Datetime column for that particular table.\\\\n\\\"\\r\\n  distractor \\\"An object representing an instance of a model\\\", :explanation => \\\"\\\\nThis is a good example of trying to infer intent from good variable names and good code structure.  Since we are calling a method <tt>release_date</tt> on <tt>t</tt>, we might ask: on what types of objects might such a method be meaningfully defined?  Certainly not a database, since a database can have many tables, anby one of which might have one or more Datetime columns; nor an instance of a model, for the same reason.  It does, however, make sense if <tt>t</tt> is a table to specify a Datetime column for that particular table.\\\\n\\\"\\r\\n  distractor \\\"It could be anything; not enough information to tell\\\", :explanation => \\\"\\\\nThis is a good example of trying to infer intent from good variable names and good code structure.  Since we are calling a method <tt>release_date</tt> on <tt>t</tt>, we might ask: on what types of objects might such a method be meaningfully defined?  Certainly not a database, since a database can have many tables, anby one of which might have one or more Datetime columns; nor an instance of a model, for the same reason.  It does, however, make sense if <tt>t</tt> is a table to specify a Datetime column for that particular table.\\\\n\\\"\\r\\nend\""
(byebug) params[:ruql_source].to_json
problem[:json]
problem[:json].to_s
problem[:json]
problem
params[:ruql_source].to_json
params[:ruql_source]
problem[:json]
problem
params
problem[:json]
problem[:ruql_source]
problem = Problem.find_by_uid(id)
problem
id = id = params[:parent_uid]
problem[:json]
params[:ruql_source].to_json
params[:ruql_source]
params[:ruql_source].to_s
params[:ruql_source].to_r
params[:ruql_source].to_d
params[:ruql_source].to_j
problem[:json]
params[:ruql_source].to_json
problem[:json]
params[:ruql_source].to_s
params[:ruql_source]
problem[:json].to_s
problem[:json]
problem
problem[:text]
problem[:json]
params[:json]
params[:ruql_source]
params[:json]
problem[:json]
problem
n
c
problem[:json]
planb[:json]
planb
a
planb
planb =RuqlReader.read_problem(@current_user, params[:ruql_source])
b
b =RuqlReader.read_problem(@current_user, params[:ruql_source])
b = = RuqlReader.read_problem(@current_user, params[:ruql_source])
@ruql_source
problem
problem[:text]
a
problem[:json]
problem[:ruql_source]
problem = Problem.find_by_uid(id)
id = params[:parent_uid]
a
a = params[:ruql_source]
s
s = params[:ruql_source]
params[:ruql_source]
params
c
n
c
n
c
problem[:is_public]
problem[:json]
problem
problem = Problem.find_by_uid(id)
id = params[:parent_uid]
params[:ruql_source]
uid[:json]
uid[:text]
uid
uid[:text]
uid.text
uid = Problem.find_by_uid(id)
uid
uid = params[:parent_uid]
id = params[:parent_uid]
Problem.find_by_uid(id)
id = Problem.find_by_uid(id)
Problem.find_by_uid(id)
id = Problem.find_by_uid(id)
id
id = Problem.find_by_uid(id)
Problem.find_by_uid(id)
Problem.find_byID(id)
Problem.find_byid(id)
Problem.find(id)
Problem.find_id(id)
Problem.find_by_id(id)
id =params[:parent_uid]
params[:parent_uid]
problem = Problem.find(params[:parent_uid])
problem
params[:ruql_source]
params
c
n
c
params[:parent_uid]
c
params[:parent_uid]
params
c
params
c
params[:id]
params[:uid]
params
c
params
c
params[:parent_uid]
params
c
params
params.to_json
params.to_j
params[:uid]
c
params[:uid]
params[:current_UID]
params[:current_uid]
params
c
params
params[:previous]
c
params[:previous]
params[:uid]
params
c
problem
@problem
params[:action]
params[:id]
params
c
params
params[:id]
c
cc
c
n
c
@current_user.respond_to?(:collections)
@current_user
c
@collections
q
c
user.instructor?
user
exit()
params
exit()
eixt()
"provider"
params
c
n
User.dev_users
exit()
User.dev_users
exit()
n
User.dev_users
exit()
User.dev_users
exit()
User.dev_users
User.all
User
c
n
c
username
c
username
c
n
c
n
Problem.search
Problem.count
problems
Problem.count
Problem
n
c
n
c
@current_user
c
n
provider
username
c
n
q
exit
provider
